/*globals define*/
/*jshint node:true, browser:true*/

/**
 * Generated by PluginGenerator 2.16.0 from webgme on Mon Nov 13 2017 20:40:28 GMT-0600 (Central Standard Time).
 * A plugin that inherits from the PluginBase. To see source code documentation about available
 * properties and methods visit %host%/docs/source/PluginBase.html.
 */

var ejs = require('ejs');
var TreeModel = require('tree-model');

define([
    'plugin/PluginConfig',
    'text!./metadata.json',
    'plugin/PluginBase'
], function (
    PluginConfig,
    pluginMetadata,
    PluginBase) {
    'use strict';

    pluginMetadata = JSON.parse(pluginMetadata);

    /**
     * Initializes a new instance of SparkCodeGen.
     * @class
     * @augments {PluginBase}
     * @classdesc This class represents the plugin SparkCodeGen.
     * @constructor
     */
    var SparkCodeGen = function () {
        // Call base class' constructor.
        PluginBase.call(this);
        this.pluginMetadata = pluginMetadata;
    };

    /**
     * Metadata associated with the plugin. Contains id, name, version, description, icon, configStructue etc.
     * This is also available at the instance at this.pluginMetadata.
     * @type {object}
     */
    SparkCodeGen.metadata = pluginMetadata;

    // Prototypical inheritance from PluginBase.
    SparkCodeGen.prototype = Object.create(PluginBase.prototype);
    SparkCodeGen.prototype.constructor = SparkCodeGen;

    /**
     * Main function for the plugin to execute. This will perform the execution.
     * Notes:
     * - Always log with the provided logger.[error,warning,info,debug].
     * - Do NOT put any user interaction logic UI, etc. inside this method.
     * - callback always has to be called even if error happened.
     *
     * @param {function(string, plugin.PluginResult)} callback - the result callback
     */
    // SparkCodeGen.prototype.main = function (callback) {
    //     // Use self to access core, project, result, logger etc from PluginBase.
    //     // These are all instantiated at this point.
    //     var self = this,
    //         nodeObject;
    //
    //
    //     // Using the logger.
    //     self.logger.debug('This is a debug message.');
    //     self.logger.info('This is an info message.');
    //     self.logger.warn('This is a warning message.');
    //     self.logger.error('This is an error message.');
    //
    //     // Using the coreAPI to make changes.
    //
    //     nodeObject = self.activeNode;
    //
    //     // (1)
    //     //self.core.setAttribute(nodeObject, 'name', 'My new obj');
    //     //self.core.setRegistry(nodeObject, 'position', {x: 70, y: 70});
    //
    //
    //     // (2)
    //     self.loadNodeMap(self.rootNode)
    //         .then(function (nodes) {
    //             self.logger.info(Object.keys(nodes));
    //             self.result.setSuccess(true);
    //             callback(null, self.result);
    //         })
    //         .catch(function (err) {
    //             // (3)
    //             self.logger.error(err.stack);
    //             // Result success is false at invocation.
    //             callback(err, self.result);
    //         });
    //
    // };
    
    SparkCodeGen.prototype.main = function (callback) {
        //define(['ejs'], function(ejs){


        var self = this;
        var activeNode = this.activeNode;
        var core = this.core;
        var logger = this.logger;
        var tree = { // Root of node tree
            name: 'ROOT'
        };
        var metaArray = [];  // array of meta-nodes
        var artifact = null;

        var allNodes = new Set();


        function getAllComponents(nodes){

            // logger.info("got in getAllComp()");

            // logger.info("all nodes", nodes);

            let allComponents = new Set();

            for(let node of nodes){

                // logger.info("nodes", node);

                let metaTypeNode = core.getMetaType(node);
                let metaType = core.getAttribute(metaTypeNode, 'name');

                logger.info("meta type is ", metaType);

                if (metaType !== "Model" &&
                        metaType !== "Connection" &&
                        metaType !== "Input" &&
                        metaType !== "Output" &&
                        metaType !== "Port"){

                    allComponents.add(node);
                }

            }

            logger.info("set of nodes", allComponents);

            tree.testallcomp = [];

            for(let node of allComponents){

                tree.testallcomp.push(core.getAttribute(node, 'name'));

            }

            logger.info("all component names", tree.testallcomp);


            return allComponents;

        }


        // function getSequenceGraph(nodes){
        //
        //     nodesNotinSequence = ;
        //
        //     tree = ;
        //     root = ;
        //
        //     currLevel = [];
        //     nodesInTree = set;
        //     delayNodes = set;
        //
        //     for (all src nodes){
        //         let node = root.addChild;
        //         curlevel.add(node);
        //         nodesInTree.add(node);
        //     }
        //
        //     while (nodesNotinSequence.size != 0){
        //
        //         let newChildren = [];
        //         for (node of curlevel){
        //             newChildren.add({node: node.children, parent:node}); // todo | add in function, and add ports to tree
        //             // TODO | won't work for multple children per port
        //         }
        //
        //         newChidren += delayNodes;
        //
        //         let validatedNodes = []
        //         let delayNodes = []
        //
        //         for (node of newChildren){
        //             let parents = node.parents();
        //             let isValid = True;
        //             for (parent of parents){
        //                 if parent not in nodesInTree: isValid = False
        //             }
        //
        //             if (isValid) {
        //                 validatedNodes.add(node)
        //             } else {
        //                 delayNodes.add(node)
        //             }
        //
        //         }
        //
        //         let newCurLevel = []
        //
        //         for (node of validatedNodes){
        //             newCurLevel.add(node.parent.addChild(node.node));
        //         }
        //
        //         // update delayed nodes to all delayNodes
        //
        //         curlevel = newCurlevel;
        //
        //
        //
        //     }
        //
        //
        // }


        // Check if the node is a meta node
        function isMeta(node) {

            let name = core.getAttribute(node, 'name');
            if (self.META.hasOwnProperty(name) && self.core.getPath(self.META[name]) === self.core.getPath(node)) {
                return true;
            } else {
                return false;
            }
        }

        // Get node's meta type
        function getMetaType(node) {

            let metaNode = null;
            if (isMeta(node)) {
                metaNode = node;
            } else {
                metaNode = self.core.getBase(node);
            }

            return metaNode;

        };

        // add a meta node to the meta array
        function addMetaNode(node) {
            let metaNodeData = {};

            // Get name
            metaNodeData.name = core.getAttribute(node, 'name')

            // Get the full path of the meta node
            metaNodeData.path = core.getPath(node)

            // Get the number of children
            metaNodeData.nbrOfChildren = core.getChildrenRelids(node).length;

            // Get the base node of the META node
            let baseNode = core.getBase(node)
            if (baseNode !== null) {
                metaNodeData.base = core.getAttribute(baseNode, 'name');
            } else {
                metaNodeData.base = null;
            }

            // push the the json to the state array
            metaArray.push(metaNodeData)
        }

        // Get the data for a node (except ROOT node)
        function getNodeData(node, nodeMap) {

            allNodes.add(node);


            if(core.getAttribute(node, 'name') === "TrainingData"){

                tree.madeit = "yes";

                let floc = core.getAttribute(node, 'FileLocation');

                let dataTemplate = String(core.getAttribute(node, 'EJSTemplate'));
                // let dataTemplate = "<%= outputVar1 %> = <%=sparkVar%>.read.load('<%=FileLocation%>')"
                let dataNode = {
                    inputFile: floc,
                    guid: "123456data",
                    requirements: []
                };


                let sparkVar = 'spark';  // TODO | always start with a spark session being created. Need to have this be a node

                // let dataInput = {
                //     outputVar1: dataNode.guid,  // TODO | what if multiple 'outputs'?
                //     sparkVar: sparkVar,
                //     FileLocation: dataNode.inputFile
                // };
                tree.templ = dataTemplate;
                tree.check2 = ejs.render(dataTemplate, {DataOut: "output", sparkVar: "spark", FileLocation: "file"});

            }

            // set up part of JSON
            let nodeData = {
                name: '',
                isMeta: '',
                metaType: ''
            };

            nodeData.children = {};

            // get all of the valid attributes for the node
            let attrs = core.getValidAttributeNames(node);
            for (let i = 0; i < attrs.length; i += 1) {
                nodeData[attrs[i]] = core.getAttribute(node, attrs[i]);

            }

            // nodeData.name = core.getAttribute(node, 'name');

            // get node's metatype
            let metaTypeOfNode = getMetaType(node);
            nodeData.metaType = core.getAttribute(metaTypeOfNode, 'name')

            // Recurs. call for node's children.
            let childrenPaths = core.getChildrenPaths(node);

            for (let j = 0; j < childrenPaths.length; j += 1) {

                let childNode = nodeMap[childrenPaths[j]];
                let childNodeData = getNodeData(childNode, nodeMap);
                let childRelId = core.getRelid(childNode);

                nodeData.children[childRelId] = childNodeData;
            }

            // If meta node:
            if (isMeta(node)) {
                addMetaNode(node)
                nodeData.isMeta = 'true'
            } else {
                nodeData.isMeta = 'false'
            }

            // check to see if it's a connection
            if (self.isMetaTypeOf(node, self.META.Flow) && !isMeta(node)) {

                let srcPath = core.getPointerPath(node, 'src');
                let dstPath = core.getPointerPath(node, 'dst');

                if (srcPath && dstPath) {

                    let srcNode = nodeMap[srcPath];
                    let dstNode = nodeMap[dstPath];

                    let srcParent = core.getParent(srcNode);
                    let dstParent = core.getParent(dstNode);

                    nodeData.src = core.getAttribute(srcParent, 'name') + '.' + core.getAttribute(srcNode, 'name');
                    nodeData.dst = core.getAttribute(dstParent, 'name') + '.' + core.getAttribute(dstNode, 'name');
                }
            }

            // logger.info(JSON.stringify(nodeData))

            return nodeData
        }

        this
            .loadNodeMap(activeNode)
            .then((nodeMap) => {



                let rootChildren = core.getChildrenPaths(activeNode);

                tree.children = {};

                // Get the data for all of the root's children
                for (let i = 0; i < rootChildren.length; i += 1) {

                    let childNode = nodeMap[rootChildren[i]];
                    let childRelId = core.getRelid(childNode);

                    allNodes.add(childNode);

                    tree.children[childRelId] = getNodeData(childNode, nodeMap);

                    if(getMetaType(childNode) == "TrainingData"){

                        tree.madeit = "yes";

                        let dataTemplate = core.getAttribute(childNode, 'EJSTemplate');
                        let dataNode = {
                            inputFile: core.getAttribute(childNode, 'FileLocation'),
                            guid: "123456data",
                            requirements: []
                        };
                        let sparkVar = 'spark';  // TODO | always start with a spark session being created. Need to have this be a node

                        let dataInput = {
                            DataOut: dataNode.guid,  // TODO | what if multiple 'outputs'?
                            sparkVar: sparkVar,
                            FileLocation: dataNode.inputFile
                        };
                        tree.check2 = ejs.render(dataTemplate, dataInput);

                    }

                }

                let test = getAllComponents(allNodes);

                // let dataTemplate = '<%= outputVar1 %> = <%=sparkVar%>.read.load(\"<%=inputVar1%>\")';
                // let dataNode = {
                //     inputFile: "example.json",
                //     guid: "123456data",
                //     requirements: []
                // };
                // let sparkVar = 'spark';  // TODO | always start with a spark session being created. Need to have this be a node
                //
                // let dataInput = {
                //     DataOut: dataNode.guid,  // TODO | what if multiple 'outputs'?
                //     sparkVar: sparkVar,
                //     inputVar1: dataNode.inputFile
                // };
                // tree.check = ejs.render(dataTemplate, dataInput);

                // logger.debug('tree', JSON.stringify(tree, null, 2));
                // logger.debug(metaArray);

                artifact = self.blobClient.createArtifact('results');
                return artifact.addFiles({
                    'tree.json': JSON.stringify(tree, null, 2),
                    'meta.json': JSON.stringify(metaArray)
                });

            }).then((metadataHash) => {

            logger.info(metadataHash);
            self.result.setSuccess(true);
            return artifact.save();

        }).then(artifactHash => {

            self.result.addArtifact(artifactHash);
            self.result.setSuccess(true);
            callback(null, self.result);

        }).catch(function (err) {

            logger.error(err);
            callback(err);
        });
        //})};
    };
    

    return SparkCodeGen;
});
