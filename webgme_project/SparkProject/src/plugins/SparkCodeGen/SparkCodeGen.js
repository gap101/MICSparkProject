/*globals define*/
/*jshint node:true, browser:true*/

/**
 * Generated by PluginGenerator 2.16.0 from webgme on Mon Nov 13 2017 20:40:28 GMT-0600 (Central Standard Time).
 * A plugin that inherits from the PluginBase. To see source code documentation about available
 * properties and methods visit %host%/docs/source/PluginBase.html.
 */

const ejs = require('ejs');
const TreeModel = require('tree-model');

define([
    'plugin/PluginConfig',
    'text!./metadata.json',
    'plugin/PluginBase'
], function (
    PluginConfig,
    pluginMetadata,
    PluginBase) {
    'use strict';

    pluginMetadata = JSON.parse(pluginMetadata);

    /**
     * Initializes a new instance of SparkCodeGen.
     * @class
     * @augments {PluginBase}
     * @classdesc This class represents the plugin SparkCodeGen.
     * @constructor
     */
    var SparkCodeGen = function () {
        // Call base class' constructor.
        PluginBase.call(this);
        this.pluginMetadata = pluginMetadata;
    };

    /**
     * Metadata associated with the plugin. Contains id, name, version, description, icon, configStructue etc.
     * This is also available at the instance at this.pluginMetadata.
     * @type {object}
     */
    SparkCodeGen.metadata = pluginMetadata;

    // Prototypical inheritance from PluginBase.
    SparkCodeGen.prototype = Object.create(PluginBase.prototype);
    SparkCodeGen.prototype.constructor = SparkCodeGen;

    /**
     * Main function for the plugin to execute. This will perform the execution.
     * Notes:
     * - Always log with the provided logger.[error,warning,info,debug].
     * - Do NOT put any user interaction logic UI, etc. inside this method.
     * - callback always has to be called even if error happened.
     *
     * @param {function(string, plugin.PluginResult)} callback - the result callback
     */
    SparkCodeGen.prototype.main = function (callback) {
        //define(['ejs'], function(ejs){


        var self = this;
        var activeNode = this.activeNode;
        var core = this.core;
        var logger = this.logger;

        var jsonTree = {
            // Root of node jsonTree
            name: 'ROOT'
        };
        var metaArray = [];  // array of meta-nodes
        var artifact = null;

        // Set of all nodes present in current context
        var allNodes = new Set();

        var componentDataDictionary = {};


        function applyTemplate(componentData){
            return ejs.render(String(componentData.EJSTemplate), componentData);
        }

        /**
         * Return a set of all the names of Component nodes in current context
         * @param nodes: all nodes in current context of any type
         * @returns {Set}
         */
        function getAllComponents(nodes, nodeMap){
            let allComponents = new Set();

            // Loop through all nodes
            for(let node of nodes){
                let metaTypeNode = core.getMetaType(node);
                let metaType = core.getAttribute(metaTypeNode, 'name');

                if (metaType !== "Model" &&
                        metaType !== "Connection" &&
                        metaType !== "Input" &&
                        metaType !== "Output" &&
                        metaType !== "Port"){

                    //{node: nodeObj,
                    //  data: nodeData,
                    //  connections:
                    //      {src: [        // Connections this is a source for
                    //          {guid: guid, src:, dst, srcPort, destPort},
                    //       ],
                    //      dest: []
                    //  }

                    allComponents.add(node);
                    componentDataDictionary[core.getGuid(node)] = {
                        data: getComponentJsonData(node, nodeMap),
                        connections: {src: [], dst: []}
                    };
                }
            }
            // logger.info('all')
            // logger.info('all Components: ', allComponents);
            logger.info('all nodes data1: ', componentDataDictionary);

            // Add all connections
            for(let node of nodes){
                let metaTypeNode = core.getMetaType(node);
                let metaType = core.getAttribute(metaTypeNode, 'name');

                if (metaType === "Connection"){

                    let srcPath = core.getPointerPath(node, 'src');
                    let dstPath = core.getPointerPath(node, 'dst');

                    if (srcPath && dstPath) {

                        let connGuid = core.getGuid(node);

                        let srcPortNode = nodeMap[srcPath];
                        let dstPortNode = nodeMap[dstPath];

                        let srcPortName = core.getAttribute(srcPortNode, 'name');
                        let dstPortName = core.getAttribute(dstPortNode, 'name');

                        let srcComp = core.getParent(srcPortNode);
                        let dstComp = core.getParent(dstPortNode);

                        componentDataDictionary[core.getGuid(srcComp)].connections.src.push({
                            guid: connGuid,
                            srcPort: srcPortName,
                            srcNode: srcComp,
                            destPort: dstComp,
                            destNode: dstComp
                        });

                        componentDataDictionary[core.getGuid(dstComp)].connections.dst.push({
                            guid: connGuid,
                            srcPort: srcPortName,
                            srcNode: srcComp,
                            destPort: dstComp,
                            destNode: dstComp
                        });

                        componentDataDictionary[core.getGuid(srcComp)].data[srcPortName] = connGuid;
                        componentDataDictionary[core.getGuid(dstComp)].data[dstPortName] = connGuid;
                    }
                }
            }

            return allComponents;
        }


        function getSequenceGraph(components, dataDictionary) {

            let compNotInSeq = components.copy()

        }

        // Check if the node is a meta node
        function isMeta(node) {

            let name = core.getAttribute(node, 'name');
            if (self.META.hasOwnProperty(name) && self.core.getPath(self.META[name]) === self.core.getPath(node)) {
                return true;
            } else {
                return false;
            }
        }

        // Get node's meta type
        function getMetaType(node) {

            let metaNode = null;
            if (isMeta(node)) {
                metaNode = node;
            } else {
                metaNode = self.core.getBase(node);
            }

            return metaNode;

        };

        // add a meta node to the meta array
        function addMetaNode(node) {
            let metaNodeData = {};

            // Get name
            metaNodeData.name = core.getAttribute(node, 'name')

            // Get the full path of the meta node
            metaNodeData.path = core.getPath(node)

            // Get the number of children
            metaNodeData.nbrOfChildren = core.getChildrenRelids(node).length;

            // Get the base node of the META node
            let baseNode = core.getBase(node)
            if (baseNode !== null) {
                metaNodeData.base = core.getAttribute(baseNode, 'name');
            } else {
                metaNodeData.base = null;
            }

            // push the the json to the state array
            metaArray.push(metaNodeData)
        }

        /**
         * add all nodes in the model to the set allNodes
         * @param node
         * @param nodeMap
         */
        function initAllNodes(node, nodeMap) {

            allNodes.add(node);

            // Recurs. call for node's children.
            let childrenPaths = core.getChildrenPaths(node);

            logger.info('paths', childrenPaths);

            for (let j = 0; j < childrenPaths.length; j += 1) {
                let childNode = nodeMap[childrenPaths[j]];

                initAllNodes(childNode, nodeMap);
            }
        }

        /**
         * Return the json data for a component
         * @param node
         * @param nodeMap
         * @returns {{name: string, isMeta: string, metaType: string}}
         */
        function getComponentJsonData(node, nodeMap){
            // set up part of JSON
            let nodeData = {
                name: '',
                isMeta: '',
                metaType: ''
            };

            nodeData.children = {};

            // get all of the valid attributes for the node
            let attrs = core.getValidAttributeNames(node);
            for (let i = 0; i < attrs.length; i += 1) {
                nodeData[attrs[i]] = core.getAttribute(node, attrs[i]);
            }

            // get node's metatype
            let metaTypeOfNode = getMetaType(node);
            nodeData.metaType = core.getAttribute(metaTypeOfNode, 'name');

            nodeData.guid = core.getGuid(node);

            return nodeData
        }

        // Return the data for a node (except ROOT node)
        function getNodeData(node, nodeMap) {

            if(core.getAttribute(node, 'name') === "TrainingData"){

                jsonTree.madeit = "yes";

                let floc = core.getAttribute(node, 'FileLocation');

                let dataTemplate = String(core.getAttribute(node, 'EJSTemplate'));
                // let dataTemplate = "<%= outputVar1 %> = <%=sparkVar%>.read.load('<%=FileLocation%>')"
                let dataNode = {
                    inputFile: floc,
                    guid: "123456data",
                    requirements: []
                };


                let sparkVar = 'spark';  // TODO | always start with a spark session being created. Need to have this be a node

                // let dataInput = {
                //     outputVar1: dataNode.guid,  // TODO | what if multiple 'outputs'?
                //     sparkVar: sparkVar,
                //     FileLocation: dataNode.inputFile
                // };
                jsonTree.templ = dataTemplate;
                jsonTree.check2 = ejs.render(dataTemplate, {DataOut: "output", sparkVar: "spark", FileLocation: "file"});

            }

            // set up part of JSON
            let nodeData = {
                name: '',
                isMeta: '',
                metaType: ''
            };

            nodeData.children = {};

            // get all of the valid attributes for the node
            let attrs = core.getValidAttributeNames(node);
            for (let i = 0; i < attrs.length; i += 1) {
                nodeData[attrs[i]] = core.getAttribute(node, attrs[i]);

            }

            // nodeData.name = core.getAttribute(node, 'name');

            // get node's metatype
            let metaTypeOfNode = getMetaType(node);
            nodeData.metaType = core.getAttribute(metaTypeOfNode, 'name')

            // Recurs. call for node's children.
            let childrenPaths = core.getChildrenPaths(node);

            for (let j = 0; j < childrenPaths.length; j += 1) {

                let childNode = nodeMap[childrenPaths[j]];
                let childNodeData = getNodeData(childNode, nodeMap);
                let childRelId = core.getRelid(childNode);

                nodeData.children[childRelId] = childNodeData;
            }

            // If meta node:
            if (isMeta(node)) {
                addMetaNode(node)
                nodeData.isMeta = 'true'
            } else {
                nodeData.isMeta = 'false'
            }

            // check to see if it's a connection
            if (self.isMetaTypeOf(node, self.META.Connection) && !isMeta(node)) {

                let srcPath = core.getPointerPath(node, 'src');
                let dstPath = core.getPointerPath(node, 'dst');

                if (srcPath && dstPath) {

                    let srcNode = nodeMap[srcPath];
                    let dstNode = nodeMap[dstPath];

                    let srcParent = core.getParent(srcNode);
                    let dstParent = core.getParent(dstNode);

                    nodeData.src = core.getAttribute(srcParent, 'name') + '.' + core.getAttribute(srcNode, 'name');
                    nodeData.dst = core.getAttribute(dstParent, 'name') + '.' + core.getAttribute(dstNode, 'name');
                }
            }

            // logger.info(JSON.stringify(nodeData))

            return nodeData
        }

        this
            .loadNodeMap(activeNode)
            .then((nodeMap) => {

                let rootChildren = core.getChildrenPaths(activeNode);

                // Init the allNodes variable
                for (let i = 0; i < rootChildren.length; i += 1) {
                    let childNode = nodeMap[rootChildren[i]];
                    initAllNodes(childNode, nodeMap)
                }

                // Get set of all node components and init componentDataDictionary:
                let allComponents = getAllComponents(allNodes, nodeMap);

                // TODO | test the templating
                for(let node of allComponents){

                    // logger.info('guid', String(core.getGuid(node)));
                    // logger.info('data')

                    logger.info(String(applyTemplate(componentDataDictionary[core.getGuid(node)].data)));
                }

                // Find correct sequence of components


                // jsonTree.children = {};
                //
                // // Get the data for all of the root's children
                // for (let i = 0; i < rootChildren.length; i += 1) {
                //
                //     let childNode = nodeMap[rootChildren[i]];
                //     let childRelId = core.getRelid(childNode);
                //
                //     allNodes.add(childNode);
                //
                //     jsonTree.children[childRelId] = getNodeData(childNode, nodeMap);
                //
                // }

                // let test = getAllComponents(allNodes);

                // let dataTemplate = '<%= outputVar1 %> = <%=sparkVar%>.read.load(\"<%=inputVar1%>\")';
                // let dataNode = {
                //     inputFile: "example.json",
                //     guid: "123456data",
                //     requirements: []
                // };
                // let sparkVar = 'spark';  // TODO | always start with a spark session being created. Need to have this be a node
                //
                // let dataInput = {
                //     DataOut: dataNode.guid,  // TODO | what if multiple 'outputs'?
                //     sparkVar: sparkVar,
                //     inputVar1: dataNode.inputFile
                // };
                // jsonTree.check = ejs.render(dataTemplate, dataInput);

                // logger.debug('jsonTree', JSON.stringify(jsonTree, null, 2));
                // logger.debug(metaArray);

                artifact = self.blobClient.createArtifact('results');
                return artifact.addFiles({
                    'jsonTree.json': JSON.stringify(jsonTree, null, 2),
                    'meta.json': JSON.stringify(metaArray)
                });

            }).then((metadataHash) => {

            logger.info(metadataHash);
            self.result.setSuccess(true);
            return artifact.save();

        }).then(artifactHash => {

            self.result.addArtifact(artifactHash);
            self.result.setSuccess(true);
            callback(null, self.result);

        }).catch(function (err) {

            logger.error(err);
            callback(err);
        });
        //})};
    };
    

    return SparkCodeGen;
});
